"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublishingTokens = void 0;
const publishingTokensCreate_js_1 = require("../funcs/publishingTokensCreate.js");
const publishingTokensDelete_js_1 = require("../funcs/publishingTokensDelete.js");
const publishingTokensGet_js_1 = require("../funcs/publishingTokensGet.js");
const publishingTokensList_js_1 = require("../funcs/publishingTokensList.js");
const publishingTokensResolveMetadata_js_1 = require("../funcs/publishingTokensResolveMetadata.js");
const publishingTokensResolveTarget_js_1 = require("../funcs/publishingTokensResolveTarget.js");
const publishingTokensUpdate_js_1 = require("../funcs/publishingTokensUpdate.js");
const sdks_js_1 = require("../lib/sdks.js");
const fp_js_1 = require("./types/fp.js");
class PublishingTokens extends sdks_js_1.ClientSDK {
    /**
     * Create a publishing token for a workspace
     *
     * @remarks
     * Creates a publishing token for the current workspace
     */
    async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, publishingTokensCreate_js_1.publishingTokensCreate)(this, request, options));
    }
    /**
     * Delete a specific publishing token
     *
     * @remarks
     * Delete a particular publishing token.
     */
    async delete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, publishingTokensDelete_js_1.publishingTokensDelete)(this, request, options));
    }
    /**
     * Get a specific publishing token
     *
     * @remarks
     * Get information about a particular publishing token.
     */
    async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, publishingTokensGet_js_1.publishingTokensGet)(this, request, options));
    }
    /**
     * Get publishing tokens for a workspace
     *
     * @remarks
     * Returns a publishing token for the current workspace
     */
    async list(options) {
        return (0, fp_js_1.unwrapAsync)((0, publishingTokensList_js_1.publishingTokensList)(this, options));
    }
    /**
     * Get metadata about the token
     *
     * @remarks
     * Get information about a particular publishing token.
     */
    async resolveMetadata(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, publishingTokensResolveMetadata_js_1.publishingTokensResolveMetadata)(this, request, options));
    }
    /**
     * Get a specific publishing token target
     *
     * @remarks
     * Get information about a particular publishing token target.
     */
    async resolveTarget(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, publishingTokensResolveTarget_js_1.publishingTokensResolveTarget)(this, request, options));
    }
    /**
     * Updates the validitity period of a publishing token
     *
     * @remarks
     * Updates the validity period of a particular publishing token.
     */
    async update(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, publishingTokensUpdate_js_1.publishingTokensUpdate)(this, request, options));
    }
}
exports.PublishingTokens = PublishingTokens;
//# sourceMappingURL=publishingtokens.js.map